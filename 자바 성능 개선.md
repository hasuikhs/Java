# 자바 성능 개선

참고: [제레미의 블로그](https://sungjk.github.io/2019/03/28/java-performance-tuning-1.html)

## 1. String 사용을 줄이자

- 일반적으로 쿼리 문장을 작성해보면, 다음과 같이 작성한다.

  ```java
  String strSQL = "";
  str += "select * ";
  str += "from ( ";
  str += "select A_column, ";
  str += "B_column, ";
  ...
  ```

- 이와 같이 String으로 코딩하면 다음과 같은 메모리 사용량을 확인 가능하다.

  |     구분      |       결과       |
  | :-----------: | :--------------: |
  | 메모리 사용량 | 10회 평균 약 5mb |
  |   응답 시간   | 10회 평균 약 5ms |

- 위 코드를 메모리 사용량과 응답 시간을 줄이기 위해 StringBuilder로 변경하자.

  ```java
  StringBuilder strSQL = new StringBuilder();
  strSQL.append("select * ");
  strSQL.append(" from ( ");
  strSQL.append(" select A_column, ");
  strSQL.append(" Bc_column, ");
  ...
  ```

- 이와 같이 StringBuilder를 이용해서 변경할 경우의 메모리 사용량과 응답 시간을 살펴보자.

  |     구분      |        결과        |
  | :-----------: | :----------------: |
  | 메모리 사용량 | 10회 평균 약 371kb |
  |   응답 시간   | 10회 평균 약 0.3ms |

### 1.1 StringBuffer 클래스 vs StringBuilder 클래스

- StringBuffer 클래스나 StringBuilder 클래스에서 제공하는 메서드는 동일하다.
- StringBuffer 클래스는 Thread에 안전하게(ThreadSafe) 설계되어 있으므로, **여러개의 Thread에서  하나의 StringBuffer 객체를 처리**해도 문제가 되지 않는다.
- **StringBuilder는 단일 Thread에서의 안전성만을 보장**한다.

### 1.2 String vs StringBuffer vs StringBuilder

> 그렇다면 String, StringBuffer, StringBuilder 세 개의 String 클래스에서 어느것이 가장 빠르고 메모리를 적게 사용하는지 알아보도록하자.

- 세가지 String 클래스를 이용하여 10,000 회 반복하여 문자열을 더하고, 이런 작업을 10회 반복해보면

  |     소스 코드     | 응답 시간(ms) | 소요시간 | 메모리 사용량(bytes) |  비고   |
  | :---------------: | :-----------: | :------: | :------------------: | :-----: |
  |   a += aValue;    |   95,801.41   |   95초   |   100,102,000,000    | 약 95gb |
  | b.append(aValue); |    247.48     |  0.25초  |      29,493,600      | 약 28mb |
  | c.append(cValue); |    174.17     |  0.17초  |      29,493,600      | 약 39mb |

- 왜 이러한 결과가 발생할까?

  ```java
  // String
  a += aValue
  ```

  1. 위와 같이 코딩하게  되면 더할때마다 새로운 String 객체가 만들어짐
  2. 이전에 있던 a **객체는 더이상 필요가 없어지므로 쓰레기 값이 되어 GC(GarbageCollector) 대상이 됨**
  3. **이러한 작업을 계속 반복하게 되면서 메모리를 많이 사용**하게 됨

- 그렇다면 **String**은 사용하지 말아야하나?

  - 아니다. **String 클래스는 짧은 문자열을 더할 경우** 사용하자.

- **StringBuffer**는 언제 사용해야하나?

  - Thread에 안전한 프로그램이 필요할때나, 개발 중인 시스템의 대부분이 **Thread에 안전한지를 모를 경우**
  - 만약 클래스에 **static으로 선언된 문자열을 변경**하거나, **singleton으로 선언된 클래스에 선언**된 경우

- **StrigBuilder**는 언제 사용해야하나?

  - Thread에 안전한지의 여부와 전혀 관계없는 프로그램을 개발할 경우
  - 만약, 메서드 내에 변수를 선언했다면, 그 변수는 그 메서드 내에서만 살아있으므로 StringBuilder를 사용

-----

## 2. 지금까지 사용하던 for 루프를 더 빠르게 사용해보자

- 기존의 for문과 size 메서드를 사용해서 사용하면 다음과 같았다.

  ```java
  for(int i = 0; i < list.size(); i++)
  ```

- 하지만 이렇게 사용하게 되면 **루프마다 size 메서드를 호출하기 때문에 성능 저하가 발생**한다.

- 그래서 이를 개선하기 위해서는 다음과 같이 코딩하는 것을 추천한다.

  ```java
  int listSize = list.size();
  for(int i = 0; i < listSize; i++)
  ```

-----

## 3. static을 제대로 사용하자

- 많은 클래스의 인스턴스를 생성하더라도, **static으로 선언된 변수나 메서드들을 동일한 주소값을 참조**한다.

## 3.1 static의 특징

- **다른 JVM**에서는 static으로 선언해도 **다른 주소나 다른 값을 참조**한다.
- 하지만 **하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조**한다.
- 그래서 GC의 대상도 되지 않는다.

### 3.2 static 잘 사용하기

- 자주 사용하고 **절대 변하지 않는 변수는 final static으로 선언**하자
- 설정 파일 정보도 static으로 관리하자
- 코드성 데이터느 DB에서 한 번만 읽자

